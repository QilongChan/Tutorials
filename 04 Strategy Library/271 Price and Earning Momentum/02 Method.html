<h3>Step 1: Select the coarse universe</h3> 
<p>
  In this step, we would like to choose the top 100 liquid equities with prices larger than $5. Besides, we filter out the equities without fundamental data since EPS is needed in the fine selection step. By the following method, we obtain the top 100 filtered equities as our coarse universe.
</p>

<div class="section-example-container">
<pre class="python">
def CoarseSelection(self, coarse):
  '''
  Pick the top 100 liquid equities as the coarse-selected universe
  '''
  # Before next rebalance time, just remain the current universe
  if self.Time < self.nextRebalance:
      return Universe.Unchanged

  # Sort the equities (prices > 5) by Dollar Volume descendingly
  selectedByDollarVolume = sorted([x for x in coarse if x.Price > 5 and x.HasFundamentalData], 
                                  key = lambda x: x.DollarVolume, reverse = True)

  # Pick the top 100 liquid equities as the coarse-selected universe
  return [x.Symbol for x in selectedByDollarVolume[:self.numOfCoarse]]  
</pre>
</div>

<h3>Step 2: Get quarterly return and earnings growth</h3>
<p>
  As N.Jegadeesh et al. state, momentum on price and earnings can be indicators for trading, so we derive two methods to calculate these criterion for stock selecting. In the first method "GetQuarterlyReturn", we first request the close prices of last quarter for all stocks in the coarse universe. Then, we calcuate the quarterly return using close prices of the first and the last days, and hence get the rank of each stock on quarter return. Finally, we store the symbols of stocks and their corresponding ranks in Dictionary as preperation for fine selection. 
</p>

<div class="section-example-container">
  <pre class="python">
    def GetQuarterlyReturn(self, history):
        '''
        Get the rank of securities based on their quarterly return from historical close prices
        Return: dictionary
        '''
        # Get quarterly returns for all symbols
        # (The first row divided by the last row)
        returns = history.iloc[0] / history.iloc[-1]

        # Transform them to dictionary structure
        returns = returns.to_dict()

        # Get the rank of the returns (key: symbol; value: rank)
        # (The symbol with the 1st quarterly return ranks the 1st, etc.)
        ranked = sorted(returns, key = returns.get, reverse = True)
        return {symbol: rank for rank, symbol in enumerate(ranked, 1)}
  </pre>
</div>
<p>
  Similarly, in the second method "GetEarningGrowth", our goal is to get the ranks of earnings growth for each stock in the coarse universe. Since requesting historical fundamental data is not supported yet, we apply another useful tool Rolling Window to store and update the BasicEPS in the earning report quarterly. After that, we can easily calculate the growth of the earnings for all stocks and get the ranks eventually.
</p>

<div class="section-example-container">
  <pre class="python">
    def GetEarningGrowth(self, fine):
        '''
        Get the rank of securities based on their EPS growth
        Return: dictionary
        '''

        # Earning Growth by symbol
        egBySymbol = {}
        for stock in fine:

            # Select the securities with EPS (> 0)
            if stock.EarningReports.BasicEPS.ThreeMonths == 0:
                continue

            # Add the symbol in the dict if not exist
            if not stock.Symbol in self.epsBySymbol:
                self.epsBySymbol[stock.Symbol] = RollingWindow[float](2)

            # Update the rolling window for each stock
            self.epsBySymbol[stock.Symbol].Add(stock.EarningReports.BasicEPS.ThreeMonths)

            # If the rolling window is ready
            if self.epsBySymbol[stock.Symbol].IsReady:
                rw = self.epsBySymbol[stock.Symbol]
                # Caculate the Earning Growth
                egBySymbol[stock.Symbol] = (rw[0] - rw[1]) / rw[1]

        # Get the rank of the Earning Growth
        ranked = sorted(egBySymbol, key = egBySymbol.get, reverse = True)
        return {symbol: rank for rank, symbol in enumerate(ranked, 1)}
  </pre>
</div>

<h3>Step 3: Select the fine universe</h3>  
<p>
  Based on the two indictors that measure momentum effect from the previous step, we generate an average rank for each stock and choose the top 10 to long and the bottom 10 to short.
</p>

<div class="section-example-container">
  <pre class="python">
    def FineSelection(self, fine):
        '''
        Select securities based on their quarterly return and their earnings growth 
        '''
        symbols = [x.Symbol for x in fine]

        # Get the quarterly returns for each symbol
        history = self.History(symbols, self.rebalanceDays, Resolution.Daily)
        history = history.drop_duplicates().close.unstack(level = 0)
        rankByQuarterReturn = self.GetQuarterlyReturn(history)

        # Get the earning growth for each symbol
        rankByEarningGrowth = self.GetEarningGrowth(fine) 

        # Get the sum of rank for each symbol and pick the top ones to long and the bottom ones to short
        rankSumBySymbol = {key: rankByQuarterReturn.get(key, 0) + rankByEarningGrowth.get(key, 0) 
                                for key in set(rankByQuarterReturn) | set(rankByEarningGrowth)}

        # Get 10 symbols to long and short respectively
        sortedDict = sorted(rankSumBySymbol.items(), key = lambda x: x[1], reverse = True)
        self.longSymbols = [x[0] for x in sortedDict[:10]]
        self.shortSymbols = [x[0] for x in sortedDict[-10:]]

        return [x for x in symbols if str(x) in self.longSymbols + self.shortSymbols]    
  </pre>
</div>

<h3>Step 4: Rebalance quarterly</h3>  
<p>
  We rebalance every quarter and use equal weights for the long and short positions of securities in our portfolio.
</p>

<div class="section-example-container">
  <pre class="python">
    def OnData(self, data):
        '''
        Rebalance quarterly
        '''
        # Do nothing until next rebalance
        if self.Time < self.nextRebalance:
            return

        # Liquidate the holdings if necessary
        for holding in self.Portfolio.Values:
            symbol = holding.Symbol
            if holding.Invested and symbol.Value not in self.longSymbols + self.shortSymbols:
                self.Liquidate(symbol, "Not Selected")

        # Open positions for the symbols with equal weights
        count = len(self.longSymbols + self.shortSymbols)
        if count == 0:
            return

        # Enter long positions
        for symbol in self.longSymbols:
            self.SetHoldings(symbol, 1 / count)

        # Enter short positions
        for symbol in self.shortSymbols:
            self.SetHoldings(symbol, -1 / count)

        # Set next rebalance time
        self.nextRebalance += timedelta(self.rebalanceDays)   
  </pre>
</div>